{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 import \{ randomUUID \} from 'crypto';\
import \{ WebSocketServer, WebSocket \} from 'ws';\
import \{ z \} from 'zod';\
import \{ McpServer \} from '@modelcontextprotocol/sdk/server/mcp.js';\
import \{ JSONRPCMessageSchema \} from '@modelcontextprotocol/sdk/types.js';\
\
const SUBPROTOCOL = 'mcp';\
const SERVER_INFO = \{\
  name: 'imessage-bridge-mcp',\
  version: process.env.npm_package_version ?? '1.0.0'\
\};\
\
class WebSocketTransport \{\
  constructor(socket, \{ headers, authInfo \}) \{\
    this.socket = socket;\
    this.headers = headers;\
    this.authInfo = authInfo;\
    this.sessionId = randomUUID();\
  \}\
\
  async start() \{\
    this.socket.on('close', () => \{\
      this.onclose?.();\
    \});\
\
    this.socket.on('error', (err) => \{\
      const error = err instanceof Error ? err : new Error(String(err));\
      this.onerror?.(error);\
    \});\
\
    this.socket.on('message', data => \{\
      try \{\
        const payload = typeof data === 'string' ? data : data.toString();\
        const parsed = JSONRPCMessageSchema.parse(JSON.parse(payload));\
        this.onmessage?.(parsed, \{ authInfo: this.authInfo, requestInfo: \{ headers: this.headers \} \});\
      \} catch (err) \{\
        const error = err instanceof Error ? err : new Error(String(err));\
        this.onerror?.(error);\
      \}\
    \});\
  \}\
\
  async send(message) \{\
    if (this.socket.readyState !== WebSocket.OPEN) \{\
      throw new Error('socket_not_open');\
    \}\
    await new Promise((resolve, reject) => \{\
      this.socket.send(JSON.stringify(message), (err) => \{\
        if (err) reject(err);\
        else resolve();\
      \});\
    \});\
  \}\
\
  async close() \{\
    this.socket.close();\
  \}\
\}\
\
const sendSchema = \{\
  to: z.string().regex(/^\\+?[1-9]\\d\{7,14\}$/, 'E.164 formatted number'),\
  text: z.string().min(1).max(4096)\
\};\
\
const fetchSchema = \{\
  handle: z.string().optional(),\
  chatGuid: z.string().optional(),\
  since: z.number().nonnegative().optional(),\
  limit: z.number().int().min(1).max(200).optional()\
\};\
\
const statusSchema = \{\};\
\
const makeToolResult = (payload, isError = false) => (\{\
  content: [\{ type: 'text', text: JSON.stringify(payload) \}],\
  structuredContent: payload,\
  isError\
\});\
\
const extractBearerToken = (req) => \{\
  const header = req.headers['authorization'];\
  if (typeof header === 'string' && header.toLowerCase().startsWith('bearer ')) \{\
    return header.slice(7).trim();\
  \}\
  const fallbackHeader = req.headers['x-authorization'] || req.headers['cf-authorization'];\
  if (typeof fallbackHeader === 'string' && fallbackHeader.toLowerCase().startsWith('bearer ')) \{\
    return fallbackHeader.slice(7).trim();\
  \}\
  try \{\
    const url = new URL(req.url, 'http://localhost');\
    return url.searchParams.get('token')\
      ?? url.searchParams.get('bearer')\
      ?? url.searchParams.get('auth');\
  \} catch (_) \{\
    return null;\
  \}\
\};\
\
const protocolMatches = (protocols) => \{\
  if (!protocols) return false;\
  if (typeof protocols === 'string') \{\
    return protocols.split(',').map(s => s.trim()).includes(SUBPROTOCOL);\
  \}\
  if (Array.isArray(protocols)) \{\
    return protocols.includes(SUBPROTOCOL);\
  \}\
  if (typeof protocols.has === 'function') \{\
    return protocols.has(SUBPROTOCOL);\
  \}\
  return false;\
\};\
\
function buildMcpServer(handlers, log) \{\
  const server = new McpServer(SERVER_INFO);\
\
  server.registerTool(\
    'send_imessage',\
    \{\
      title: 'Send iMessage',\
      description: 'Send an outbound iMessage to a single recipient.',\
      inputSchema: sendSchema\
    \},\
    async (\{ to, text \}) => \{\
      try \{\
        const result = await handlers.sendMessage(\{ to, text \});\
        if (result.error && !result.results?.length) \{\
          log('send_imessage denied', result.error);\
          return makeToolResult(\{ error: result.error \}, true);\
        \}\
        const first = result.results?.[0];\
        if (!first || first.status !== 200) \{\
          const error = first?.error ?? result.error ?? 'send_failed';\
          log('send_imessage failed', error);\
          return makeToolResult(\{ error \}, true);\
        \}\
        const payload = \{ ok: true, to: first.to, status: first.status \};\
        return makeToolResult(payload, false);\
      \} catch (err) \{\
        const message = err instanceof Error ? err.message : String(err);\
        log('send_imessage error', message);\
        return makeToolResult(\{ error: message \}, true);\
      \}\
    \}\
  );\
\
  server.registerTool(\
    'fetch_messages',\
    \{\
      title: 'Fetch Recent Messages',\
      description: 'Fetch buffered messages from the bridge inbox.',\
      inputSchema: fetchSchema\
    \},\
    async (args) => \{\
      try \{\
        const response = await handlers.fetchMessages(args);\
        return makeToolResult(response, false);\
      \} catch (err) \{\
        const message = err instanceof Error ? err.message : String(err);\
        log('fetch_messages error', message);\
        return makeToolResult(\{ error: message \}, true);\
      \}\
    \}\
  );\
\
  if (handlers.getStatus) \{\
    server.registerTool(\
      'get_status',\
      \{\
        title: 'Bridge Status',\
        description: 'Retrieve health/quiet hour metadata.',\
        inputSchema: statusSchema\
      \},\
      async () => \{\
        try \{\
          const status = await handlers.getStatus();\
          return makeToolResult(status, false);\
        \} catch (err) \{\
          const message = err instanceof Error ? err.message : String(err);\
          log('get_status error', message);\
          return makeToolResult(\{ error: message \}, true);\
        \}\
      \}\
    );\
  \}\
\
  return server;\
\}\
\
export async function startMcpServer(options) \{\
  const \{\
    host = '127.0.0.1',\
    port = 9797,\
    path = '/mcp',\
    bearer,\
    sendMessage,\
    fetchMessages,\
    getStatus,\
    server: existingServer\
  \} = options;\
\
  if (!bearer) throw new Error('MCP bearer token is required');\
  if (typeof sendMessage !== 'function' || typeof fetchMessages !== 'function') \{\
    throw new Error('sendMessage and fetchMessages handlers are required');\
  \}\
\
  const log = (...args) => console.log('[mcp]', ...args);\
  const warn = (...args) => console.warn('[mcp]', ...args);\
\
  const baseWsOptions = \{\
    path,\
    handleProtocols: (protocols) => (protocolMatches(protocols) ? SUBPROTOCOL : false)\
  \};\
\
  const wss = existingServer\
    ? new WebSocketServer(\{ ...baseWsOptions, server: existingServer \})\
    : new WebSocketServer(\{ ...baseWsOptions, host, port \});\
\
  wss.on('connection', (socket, req) => \{\
    const providedToken = extractBearerToken(req);\
    if (providedToken !== bearer) \{\
      warn(`rejected connection from $\{req.socket.remoteAddress ?? 'unknown'\} (auth missing/invalid)`);\
      socket.close(1008, 'unauthorized');\
      return;\
    \}\
\
    if (socket.protocol !== SUBPROTOCOL) \{\
      warn('client connected without MCP subprotocol; closing socket');\
      socket.close(1002, 'subprotocol_required');\
      return;\
    \}\
\
    const transport = new WebSocketTransport(socket, \{\
      headers: req.headers,\
      authInfo: \{ type: 'bearer', subject: 'static-token' \}\
    \});\
    const server = buildMcpServer(\{ sendMessage, fetchMessages, getStatus \}, warn);\
\
    transport.onerror = (error) => warn('transport error', error.message);\
    transport.onclose = () => server.close().catch(() => \{\});\
\
    server.connect(transport).then(() => \{\
      log(`session $\{transport.sessionId\} connected from $\{req.socket.remoteAddress ?? 'unknown'\}`);\
    \}).catch(err => \{\
      warn('connection setup failed', err.message);\
      socket.close(1011, 'server_error');\
    \});\
  \});\
\
  wss.on('error', (err) => \{\
    warn('websocket server error', err.message);\
  \});\
\
  if (existingServer) \{\
    log(`attached to existing HTTP server on path $\{path\}`);\
    return wss;\
  \}\
\
  await new Promise((resolve, reject) => \{\
    wss.once('listening', () => \{\
      log(`listening on ws://$\{host\}:$\{port\}$\{path\}`);\
      resolve();\
    \});\
    wss.once('error', reject);\
  \});\
\
  return wss;\
\}\
import \{ randomUUID \} from 'crypto';\
import \{ WebSocketServer, WebSocket \} from 'ws';\
import \{ z \} from 'zod';\
import \{ McpServer \} from '@modelcontextprotocol/sdk/server/mcp.js';\
import \{ JSONRPCMessageSchema \} from '@modelcontextprotocol/sdk/types.js';\
\
const SUBPROTOCOL = 'mcp';\
const SERVER_INFO = \{\
  name: 'imessage-bridge-mcp',\
  version: process.env.npm_package_version ?? '1.0.0'\
\};\
\
class WebSocketTransport \{\
  constructor(socket, \{ headers, authInfo \}) \{\
    this.socket = socket;\
    this.headers = headers;\
    this.authInfo = authInfo;\
    this.sessionId = randomUUID();\
  \}\
\
  async start() \{\
    this.socket.on('close', () => \{\
      this.onclose?.();\
    \});\
\
    this.socket.on('error', (err) => \{\
      const error = err instanceof Error ? err : new Error(String(err));\
      this.onerror?.(error);\
    \});\
\
    this.socket.on('message', data => \{\
      try \{\
        const payload = typeof data === 'string' ? data : data.toString();\
        const parsed = JSONRPCMessageSchema.parse(JSON.parse(payload));\
        this.onmessage?.(parsed, \{ authInfo: this.authInfo, requestInfo: \{ headers: this.headers \} \});\
      \} catch (err) \{\
        const error = err instanceof Error ? err : new Error(String(err));\
        this.onerror?.(error);\
      \}\
    \});\
  \}\
\
  async send(message) \{\
    if (this.socket.readyState !== WebSocket.OPEN) \{\
      throw new Error('socket_not_open');\
    \}\
    await new Promise((resolve, reject) => \{\
      this.socket.send(JSON.stringify(message), (err) => \{\
        if (err) reject(err);\
        else resolve();\
      \});\
    \});\
  \}\
\
  async close() \{\
    this.socket.close();\
  \}\
\}\
\
const sendSchema = \{\
  to: z.string().regex(/^\\+?[1-9]\\d\{7,14\}$/, 'E.164 formatted number'),\
  text: z.string().min(1).max(4096)\
\};\
\
const fetchSchema = \{\
  handle: z.string().optional(),\
  chatGuid: z.string().optional(),\
  since: z.number().nonnegative().optional(),\
  limit: z.number().int().min(1).max(200).optional()\
\};\
\
const statusSchema = \{\};\
\
const makeToolResult = (payload, isError = false) => (\{\
  content: [\{ type: 'text', text: JSON.stringify(payload) \}],\
  structuredContent: payload,\
  isError\
\});\
\
const extractBearerToken = (req) => \{\
  const header = req.headers['authorization'];\
  if (typeof header === 'string' && header.toLowerCase().startsWith('bearer ')) \{\
    return header.slice(7).trim();\
  \}\
  const fallbackHeader = req.headers['x-authorization'] || req.headers['cf-authorization'];\
  if (typeof fallbackHeader === 'string' && fallbackHeader.toLowerCase().startsWith('bearer ')) \{\
    return fallbackHeader.slice(7).trim();\
  \}\
  try \{\
    const url = new URL(req.url, 'http://localhost');\
    return url.searchParams.get('token')\
      ?? url.searchParams.get('bearer')\
      ?? url.searchParams.get('auth');\
  \} catch (_) \{\
    return null;\
  \}\
\};\
\
const protocolMatches = (protocols) => \{\
  if (!protocols) return false;\
  if (typeof protocols === 'string') \{\
    return protocols.split(',').map(s => s.trim()).includes(SUBPROTOCOL);\
  \}\
  if (Array.isArray(protocols)) \{\
    return protocols.includes(SUBPROTOCOL);\
  \}\
  if (typeof protocols.has === 'function') \{\
    return protocols.has(SUBPROTOCOL);\
  \}\
  return false;\
\};\
\
function buildMcpServer(handlers, log) \{\
  const server = new McpServer(SERVER_INFO);\
\
  server.registerTool(\
    'send_imessage',\
    \{\
      title: 'Send iMessage',\
      description: 'Send an outbound iMessage to a single recipient.',\
      inputSchema: sendSchema\
    \},\
    async (\{ to, text \}) => \{\
      try \{\
        const result = await handlers.sendMessage(\{ to, text \});\
        if (result.error && !result.results?.length) \{\
          log('send_imessage denied', result.error);\
          return makeToolResult(\{ error: result.error \}, true);\
        \}\
        const first = result.results?.[0];\
        if (!first || first.status !== 200) \{\
          const error = first?.error ?? result.error ?? 'send_failed';\
          log('send_imessage failed', error);\
          return makeToolResult(\{ error \}, true);\
        \}\
        const payload = \{ ok: true, to: first.to, status: first.status \};\
        return makeToolResult(payload, false);\
      \} catch (err) \{\
        const message = err instanceof Error ? err.message : String(err);\
        log('send_imessage error', message);\
        return makeToolResult(\{ error: message \}, true);\
      \}\
    \}\
  );\
\
  server.registerTool(\
    'fetch_messages',\
    \{\
      title: 'Fetch Recent Messages',\
      description: 'Fetch buffered messages from the bridge inbox.',\
      inputSchema: fetchSchema\
    \},\
    async (args) => \{\
      try \{\
        const response = await handlers.fetchMessages(args);\
        return makeToolResult(response, false);\
      \} catch (err) \{\
        const message = err instanceof Error ? err.message : String(err);\
        log('fetch_messages error', message);\
        return makeToolResult(\{ error: message \}, true);\
      \}\
    \}\
  );\
\
  if (handlers.getStatus) \{\
    server.registerTool(\
      'get_status',\
      \{\
        title: 'Bridge Status',\
        description: 'Retrieve health/quiet hour metadata.',\
        inputSchema: statusSchema\
      \},\
      async () => \{\
        try \{\
          const status = await handlers.getStatus();\
          return makeToolResult(status, false);\
        \} catch (err) \{\
          const message = err instanceof Error ? err.message : String(err);\
          log('get_status error', message);\
          return makeToolResult(\{ error: message \}, true);\
        \}\
      \}\
    );\
  \}\
\
  return server;\
\}\
\
export async function startMcpServer(options) \{\
  const \{\
    host = '127.0.0.1',\
    port = 9797,\
    path = '/mcp',\
    bearer,\
    sendMessage,\
    fetchMessages,\
    getStatus,\
    server: existingServer\
  \} = options;\
\
  if (!bearer) throw new Error('MCP bearer token is required');\
  if (typeof sendMessage !== 'function' || typeof fetchMessages !== 'function') \{\
    throw new Error('sendMessage and fetchMessages handlers are required');\
  \}\
\
  const log = (...args) => console.log('[mcp]', ...args);\
  const warn = (...args) => console.warn('[mcp]', ...args);\
\
  const baseWsOptions = \{\
    path,\
    handleProtocols: (protocols) => (protocolMatches(protocols) ? SUBPROTOCOL : false)\
  \};\
\
  const wss = existingServer\
    ? new WebSocketServer(\{ ...baseWsOptions, server: existingServer \})\
    : new WebSocketServer(\{ ...baseWsOptions, host, port \});\
\
  wss.on('connection', (socket, req) => \{\
    const providedToken = extractBearerToken(req);\
    if (providedToken !== bearer) \{\
      warn(`rejected connection from $\{req.socket.remoteAddress ?? 'unknown'\} (auth missing/invalid)`);\
      socket.close(1008, 'unauthorized');\
      return;\
    \}\
\
    if (socket.protocol !== SUBPROTOCOL) \{\
      warn('client connected without MCP subprotocol; closing socket');\
      socket.close(1002, 'subprotocol_required');\
      return;\
    \}\
\
    const transport = new WebSocketTransport(socket, \{\
      headers: req.headers,\
      authInfo: \{ type: 'bearer', subject: 'static-token' \}\
    \});\
    const server = buildMcpServer(\{ sendMessage, fetchMessages, getStatus \}, warn);\
\
    transport.onerror = (error) => warn('transport error', error.message);\
    transport.onclose = () => server.close().catch(() => \{\});\
\
    server.connect(transport).then(() => \{\
      log(`session $\{transport.sessionId\} connected from $\{req.socket.remoteAddress ?? 'unknown'\}`);\
    \}).catch(err => \{\
      warn('connection setup failed', err.message);\
      socket.close(1011, 'server_error');\
    \});\
  \});\
\
  wss.on('error', (err) => \{\
    warn('websocket server error', err.message);\
  \});\
\
  if (existingServer) \{\
    log(`attached to existing HTTP server on path $\{path\}`);\
    return wss;\
  \}\
\
  await new Promise((resolve, reject) => \{\
    wss.once('listening', () => \{\
      log(`listening on ws://$\{host\}:$\{port\}$\{path\}`);\
      resolve();\
    \});\
    wss.once('error', reject);\
  \});\
\
  return wss;\
\}\
}